
import_from_git(
  url: 'git@github.com:WW-Digital/mobile-fastlane.git',
  path: 'fastlane/MobileFastfile'
)

default_platform :ios

platform :ios do

  lane :update_framework do |options|

    #-- config
    # TODO: move this to a separate file?
    source_pod_name = "KeychainAccess"
    source_git_source = 'https://github.com/kishikawakatsumi/KeychainAccess.git'
    source_git_tag_format = 'v{build_version}'
    source_podspec_file = 'KeychainAccess.podspec'
    project_file = 'Lib/KeychainAccess.xcodeproj'
    project_scheme = 'KeychainAccess'
    #--

    podspec = read_podspec
    spec_version = podspec["version"]
    spec_name = podspec["name"]

    # TODO: get version from options, otherwise get it from cocoapods
    pod_query = `pod trunk info #{source_pod_name}`
    latest_version = pod_query.scan(/- ([0-9]+\.[0-9]+\.[0-9]+) \(.+ UTC\)/).last.first
    build_version = options[:version] || latest_version

    # if latest_version == spec_version
    #   UI.success "No update needed"
    #   next
    # end
    unless UI.confirm("Update version of #{source_pod_name} from '#{spec_version}' to '#{build_version}'?")
      UI.abort_with_message! "Canceling build"
    end

    repo_name = current_repo_name
    ensure_git_status_clean(show_uncommitted_changes: true)

    module_name = podspec["module_name"] || source_pod_name
    xcframework_name = podspec["vendored_frameworks"]
    root_path = File.expand_path('../')

    # remove current repo directory
    sh("rm -rf #{root_path}/#{module_name}")

    # clone the latest version
    source_git_tag = source_git_tag_format.sub('{build_version}', build_version)
    sh("git clone --depth 1 --branch #{source_git_tag} #{source_git_source} #{root_path}/#{module_name}")

    # remove git files
    sh("rm -rf #{root_path}/#{module_name}/.git*")

    new_podspec = read_podspec(path: "#{root_path}/#{module_name}/#{source_podspec_file}")
    new_platforms = new_podspec['platforms']
    old_platforms = podspec['platforms']
    unless new_platforms.keys == old_platforms.keys
      UI.error "Supported platforms differ (old: #{old_platforms.keys}, new: #{new_platforms.keys}"
      UI.abort_with_message! "Update the root #{spec_name}.podspec to match the new values first"
    end

    new_platforms.each { |platform, deployment_version|
      unless deployment_version == old_platforms[platform]
        UI.error "Deployment version changed for #{platform} (old: #{old_platforms[platform]}, new: #{deployment_version})"
        UI.abort_with_message! "Update the root #{spec_name}.podspec to match the new values first"
      end
    }
    platforms = new_platforms.keys.map { |platform|
      case platform
      when 'ios' then ['iOS', 'iOS Simulator']
      when 'watchos' then ['watchOS', 'watchOS Simulator']
      when 'tvos' then ['tvOS']
      when 'osx' then ['OS X']
      else []
      end
    }.flatten

    xcframework_command = 'xcodebuild -create-xcframework'

    # create archives
    platforms.each { |platform|
      UI.message "Archiving for #{platform}..."
      out = `xcodebuild archive \
              -project #{root_path}/#{module_name}/#{project_file} \
              -scheme '#{project_scheme}' \
              -configuration Release \
              -destination 'generic/platform=#{platform}' \
              -archivePath '#{root_path}/archives/#{module_name}-#{platform.tr(' ', '')}' \
              SKIP_INSTALL=NO \
              BUILD_LIBRARY_FOR_DISTRIBUTION=YES`
      unless out.include? '** ARCHIVE SUCCEEDED **'
        UI.error out
        UI.abort_with_message "** ARCHIVE FAILED **"
      end
      xcframework_command += " -framework #{root_path}/archives/#{module_name}-#{platform.tr(' ', '')}.xcarchive/Products/Library/Frameworks/#{module_name}.framework"
    }

    xcframework_command += " -output #{root_path}/#{xcframework_name}"

    # delete old xcframework
    sh("rm -rf #{root_path}/#{xcframework_name}")

    UI.message "Creating #{xcframework_name}..."
    sh(xcframework_command)

    # create a zip of the xcframework to attach to the release
    zip(
      path: "#{root_path}/#{xcframework_name}",
      output_path: "#{root_path}/archives/#{xcframework_name}.zip"
    )

    version_bump_podspec(version_number: build_version)
    release_branch = "release/#{build_version}"
    
    unless UI.confirm("Shall I continue by pushing all changes to WW-Digital/#{repo_name}?")
      UI.abort_with_message! "Canceling build"
    end

    # Cut release branch
    sh("git checkout -b #{release_branch}")
    ensure_git_branch(branch: release_branch)

    # commit all changes
    sh("git add -A && git commit -m 'Update to version #{build_version}'")

    # create a tag
    sh("git tag -a #{build_version} -m 'Add tag for #{build_version}'")

    # push everything up to origin
    push_to_git_remote(
      local_branch: release_branch,
      remote_branch: release_branch,
      tags: true
    )

      # create a release to attach the binary
    set_github_release(
      repository_name: "WW-Digital/#{repo_name}",
      api_token: ENV["GITHUB_API_TOKEN"],
      name: "Release #{build_version}",
      tag_name: "#{build_version}",
      description: "Updates #{source_pod_name} xcframework to version #{build_version}.",
      upload_assets: ["#{root_path}/archives/#{xcframework_name}.zip"]
    )

    pull_request(
      launch_url: 'true',
      base: 'main',
      message: "Update #{source_pod_name} to version #{build_version}",
      body: "Update #{source_pod_name} to version #{build_version}"
    )

    unless UI.confirm("Shall I continue by publishing the private cocoapod #{spec_name}?")
      UI.abort_with_message! "Canceling build"
    end

    # publish the pod
    pod_push(
      path: "#{spec_name}.podspec",
      repo: 'ww-digital',
      allow_warnings: true,
      verbose: true
    )
  end

end
